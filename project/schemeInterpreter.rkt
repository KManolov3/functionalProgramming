#lang racket

(define (search p l)
  (and (not (null? l))
       (or (p (car l))
           (search p (cdr l)))))

(define the-empty-env '())

(define (assoc key alist)
  (search (lambda (key-value-pair)
            (and (equal? (car key-value-pair) key)
                 key-value-pair))
          alist))

(define (del-assoc key alist)
  (filter (lambda (key-value-pair)
            (not (equal? (car key-value-pair) key)))
          alist))

(define (add-assoc key value alist)
  (cons (cons key value)
        (del-assoc key alist)))

(define (interpret code)
  (interpret-env code the-empty-env)
  )

(define (interpret-env code env)
  (if (> (length code) 1)
      (interpret-env (cdr code) (add-to-env (list-ref (car code) 1) (list-ref (car code) 2) env))
      (evaluate (car code) env)
      )
  )

(define (add-to-env definitionSignature value env)
  (if (list? definitionSignature)
      (add-func-to-env (car definitionSignature) (cdr definitionSignature) value env)
      (add-constant-to-env definitionSignature value env)
      )
  )

(define (add-func-to-env name args value env)
  (add-assoc name (list args value) env)
  )

(define (add-constant-to-env name value env)
  (add-assoc name (evaluate value env) env)
  )

(define (atom? clause)
  (not (list? clause))
  )

(define (non-empty-list? clause)
  (and (list? clause)
       (not (null? clause))
       )
  )

(define (replace-if-match definitionName definitionBody atom)
  (if (equal? atom definitionName)
      definitionBody
      atom
      )
  )

(define (evaluate clause env)
 (and
   (println clause)
   (if (or (atom? clause) (null? clause))
       (if (defined-symbol? clause env)
           (get-value clause env)
           clause)
       (let ((clause-op (evaluate (car clause) env)))
         (cond ((equal? '+ clause-op) (apply + (map (curryr evaluate env) (cdr clause))))
               ((equal? '- clause-op) (apply - (map (curryr evaluate env) (cdr clause))))
               ((equal? '* clause-op) (apply * (map (curryr evaluate env) (cdr clause))))
               ((equal? '/ clause-op) (apply / (map (curryr evaluate env) (cdr clause))))
               ((equal? 'quotient clause-op) (apply quotient (map (curryr evaluate env) (cdr clause))))
               ((equal? 'remainder clause-op) (apply remainder (map (curryr evaluate env) (cdr clause))))
               ((equal? 'max clause-op) (apply max (map (curryr evaluate env) (cdr clause))))
               ((equal? 'min clause-op) (apply min (map (curryr evaluate env) (cdr clause))))
               ((equal? '> clause-op) (apply > (map (curryr evaluate env) (cdr clause))))
               ((equal? '>= clause-op) (apply >= (map (curryr evaluate env) (cdr clause))))
               ((equal? '< clause-op) (apply < (map (curryr evaluate env) (cdr clause))))
               ((equal? '<= clause-op) (apply <= (map (curryr evaluate env) (cdr clause))))
               ((equal? 'null? clause-op) (apply null-quoted? (map (curryr evaluate env) (cdr clause))))
               ((equal? 'list? clause-op) (apply list? (map (curryr evaluate env) (cdr clause))))
               ((equal? 'equal? clause-op) (apply equal? (map (curryr evaluate env) (cdr clause))))
               ((equal? '= clause-op) (apply = (map (curryr evaluate env) (cdr clause))))
               ((equal? 'list clause-op) (apply list (map (curryr evaluate env) (cdr clause))))
               ((equal? 'cons clause-op) (apply cons (map (curryr evaluate env) (cdr clause))))
               ((equal? 'car clause-op) (apply car (map (curryr evaluate env) (cdr clause))))
               ((equal? 'cdr clause-op) (apply cdr (map (curryr evaluate env) (cdr clause))))
               ((equal? 'if clause-op) (handle-if (cdr clause) env))
               ((lambda? clause-op) (handle-lambda (cons clause-op (cdr clause)) env))
               ((equal? 'cond clause-op) (handle-cond (cdr clause) env))
               (else clause))
         )
       )
  )
  )

(define (defined-symbol? clause env)
  (assoc clause env)
  )

(define (get-value clause env)
  (let ((clause-value (assoc clause env)))
    (if (list? clause-value)
        (get-func-value (cadr clause-value) (caddr clause-value))
        (cdr clause-value)
        )
    )
  )

(define (get-func-value params body)
  (list 'lambda params body)
  )

(define (null-quoted? list)
  (or (null? list)
      (equal? list ''())
      )
  )

(define (handle-if args env)
  (if (evaluate (car args) env)
      (evaluate (cadr args) env)
      (evaluate (caddr args) env)
      )
  )

(define (lambda? clause-op)
  (or
   (equal? 'lambda clause-op)
   (and (list? clause-op)
        (equal? 'lambda (car clause-op))
        )
   )
  )

(define (handle-lambda clause env)
  (and
   (println clause)
  (if (list? (car clause))
      (calc-lambda (list-ref (car clause) 1) (list-ref (car clause) 2) (cdr clause) env)    
      clause)
   )
  )

(define (calc-lambda params body args env)
  (and
   (println params)
   (println args)
   (if (null? params)
       (evaluate body env)
       (calc-lambda (cdr params) body (cdr args) (add-to-env (car params) (evaluate (car args) env) env))
       )
   )
  )

(define (handle-cond cases env)
  (if (= (length cases) 1)
      (evaluate (cadar cases) env)
      (if (evaluate (caar cases) env)
          (evaluate (cadar cases) env)
          (handle-cond (cdr cases) env)
          )
      )
  )
(define code1 '[(define (f x) (if (< x 3) (f (+ x 1)) (+ x 2)))
                (f 1)])

(interpret code1)
;(defined-symbol? 'f (interpret code1))



